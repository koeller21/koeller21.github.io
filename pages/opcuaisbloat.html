<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Why OPC UA kinda sucks</title>
	<link rel="stylesheet" href="../styles/chota.css">
    <script type="text/javascript" src="../scripts/main.js"></script>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">


    <style>
		:root{
			--grid-maxWidth: 90rem;
		}
        body.dark {
        --bg-color: #000;
        --bg-secondary-color: #131316;
        --font-color: #f5f5f5;
        --color-grey: #ccc;
        --color-darkGrey: #777;
        }
	</style>

	
</head>

<body>
	
	<a id="top_anchor"></a>
	
	<div id="top" class="container" role="document" style="padding-top: 40px;">
		<header role="banner">
			<a href="../index.html">&#128281; back home </a>
			<h1 style="margin:0;float:right !important">
                <a href="javascript:void(0)" onclick="switchMode(this)">☀️</a>
            </h1>
			
		</header>
		
		<main role="main">
			<section>
				<header>
					<h2> Why OPC UA kinda sucks </h2>
				</header>
				<article>
					
					<p>
						I'd say I have reached a decent proficiency regarding OPC UA, having worked 
						on and off with OPC UA for multiple years. 
					</p>
					
					<p>
						My work has mostly been theory-based, as in creating (simple, non-meshed) 
						OPC UA server implementations, using mostly the 
						<a href="https://github.com/FreeOpcUa/opcua-asyncio">asyncua</a> OPC UA library, 
						writing and drafting a companion specification, and creating the information models for it. 
					</p>
					
					<p>
						What bothers me the most about OPC UA is that there is a huge marketing effort 
						to force OPC UA into the mainstream automation industry. 
					</p>
					
					<p>
						Networking protocols used in the industry should be employed because they can 
						get the job done, are easily to maintain and are well documented. I reckon
						a lot of automation industry professionals would agree. 
					</p>
					
					<p>
						OPC UA is none of that. It takes a developer to 
						<a href="https://github.com/open62541/open62541/blob/master/examples/tutorial_server_variable.c">write 5-10 lines of code </a> 
						to add a non-complex variable node to an information model.
						In the age of REST and MQTT that's unforgivable.
					</p>
					
					<p>
						OPC UA is <i><b>not</i></b> documented.
						In fact, there are quite a few tutorials out there that explain the inner workings
						of OPC UA well.
						What I mean is that the core idea and philosophy behind OPC UA is not documented. 
						At least I haven't found a concise, dead on explanation of the 
						idea behind OPC UA. 
					</p>
					
					<p>
						Not being able to understand the core idea behind something is in fact a huge issue.
						<ul>
							<li>TCP is a stateful transport protocol that also prevents flooding and congestion</li>
							<li>UDP is a stateless transport protocol which makes it lightweight</li>
							<li>Ethernet is a link layer protocol that connectes computers in a single 'collision domain' </li>
							<li>MQTT is a broker-based PubSub application protocol</li>
						</ul>
						
						But what is the core philosphy behind OPC UA? OPC 10000-1 5.2 states
						
						<ul>
							<li>"OPC UA is a platform-independent standard through which various kinds of systems and devices can communicate [...]"</li>
						</ul>
						
						Given that OPC DA was <a href="https://en.wikipedia.org/wiki/Component_Object_Model"> MS COM</a> based,
						the platform-independent part might look like progress. 
						
						However, TCP, UDP, Ethernet, HTTP, MQTT, Modbus and so on are naturally all platform-independent.
						In this day and age, drafting a network protocol that is platform-independent is not worth mentioning.
						<i> Of course </i> you should not rely on some Windows-specific middleware as part of your very
						protocol definition. The rest of above's definition is pretty generic and inexpressive.
						
					</p>
					
					<p>
						It gets even worse; Figuring out the core ideas behind OPC UA from the official
						<a href="https://reference.opcfoundation.org/">OPC UA Reference</a> proves to be impossible.
						Not only does the Online Reference contain a <b>few thousand pages</b>, but the
						linguistic style is very poor. Instead of explaining the motivation and core ideas
						behind OPC UA in simple terms, the OPC UA Reference 
						<a href="https://reference.opcfoundation.org/Core/docs/Part1/5.3/">directly</a> 
						introduces the reader to its protocol specific terminology and features.
					</p>
					
					<p>
						This is <b> very different </b> from your <a href="https://datatracker.ietf.org/doc/html/rfc1122">usual</a> IETF protocol specification, which, 
						despite being technical, also always clearly state the protocol design goals and premises.
						Why does the OPC UA Reference not do this?
					</p>
					
					<p>
						After a few months of working with OPC UA for at least 2-3h a day,
						I finally understood the central idea behind OPC UA:
					</p>
					
					<p>
						
						<ul>
							<li>
								OPC UA allows to specify abstract, XML-based information models that can be
								instantiated by a server.
							</li>
							<li>
								An information model serves as an abstract blueprint of what data tags
								can be queried from that server by clients.
							</li>
							<li>
								The big advantage is, that <i>one</i> information model can be used by <i>n</i> server's
								and all their OPC UA interfaces will look the same.
							</li>
						</ul>
						
					</p>
					
					<p>
						Compare this to your vanilla Modbus registers or MQTT topics.
						You would only exactly know what registers or topics there are if you looked at the 
						server code or be given an interface description. With OPC UA information models,
						you'd only need to know the 
						information that the OPC UA server serves a specific information model.
					</p>
					
					<p>
						So the core idea is not bad but very seldomly clearly stated. 
						Also it remains questionable whether this concept is that much advantageous 
						for day-to-day industry operations. Most Modbus, EthernetIP, MQTT, etc. servers
						run for years without ever being changed. ROS2 DDS uses a similar concept to OPC UA, the 
						<a href="https://docs.ros.org/en/galactic/Concepts/About-ROS-Interfaces.html">Interface Definition Language</a>.
						Serialization frameworks such as 
						<a href="https://capnproto.org/language.html">Cap'n Proto</a>
						or 
						<a href="https://developers.google.com/protocol-buffers/docs/proto3">Protocol Buffers</a>
						use strongly-typed IDLs as well. Compared to OPC UA, these frameworks do not define or provide the 
						socket-level means to send or receive messages.
					</p>
					
					<p>
						OPC UA sucks because the core idea behind it may be good but the execution is very poor.
						Truth is, no one will care how comprehensive and good your 
						security concepts and address space browsing services are if you can't convey your core
						idea and motivation to developers. 
					</p>
					
					<p>
						Sure, there are OPC UA protocol implementations. Of course, there are some industry adopters.
						But will there be in 20-30 years of time? One can already see that OPC UA is an out-of-date
						protocol, as they add hundreds of more pages regarding PubSub to their
						already bloated reference documentation. Which developer would want to maintain an 
						implementation of this? Which industry adopter would assign a software dev to implement an OPC UA
						server for their machine if the protocol is so complicated and poorly documented?
					</p>
					
					<p>
						It is not difficult to come up with a network protocol definition and implementation.
						So why make the protocol overly complicated and bloated? You'll be replaced by some other
						protocol, that implements the core ideas and features in a less bloated way, in the future. 
					</p>
					
					
					
				</article>
			</section>
			
		</main>

		<footer style="padding-bottom: 80px;">
			<hr>
			<a href="#top_anchor">&#128285;</a>
		</footer>
		
	</div>
	
	

	

	
	
</body>

</html>
